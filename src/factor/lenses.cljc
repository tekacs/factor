(ns factor.lenses
  (:require [lentes.core :as lentes]
            [malli.core :as m]
            [malli.error :as me]))

(def always-nil
  "Lens which ignores underlying state, always reads as nil and writes are a no-op."
  (lentes/lens
   (constantly nil)
   (constantly nil)))

(defn transform-on-read
  "Transform the underlying state on read -- writers MUST be able to handle the underlying state, not the transformed one."
  [transform-fn]
  (lentes/lens
   (fn [state] (transform-fn state))
   (fn [state update-fn] (update-fn state))))

(defn lens-from-state
  "Unprincipled lens: use a different lens, returned by lens-fn, depending on the current underlying state."
  [lens-fn]
  (lentes/lens
   (fn [state] (lentes/focus (lens-fn state) state))
   (fn [state update-fn] (lentes/over (lens-fn state) update-fn state))))

(defn spread-lens
  "Apply each of a sequence of functions to the underlying state, returning a lazy sequence."
  [underlying-lens sequence]
  (let [lenses (map underlying-lens sequence)]
    (lentes/lens
     (fn [state] (map #(lentes/focus % state) lenses))
     (fn [state update-fn] (map #(lentes/over % update-fn state) lenses)))))

(comment
  (lentes/focus (spread-lens transform-on-read [inc dec]) 0))

(defn filter-sequence
  "Filter a sequence in the underlying state with a predicate function."
  [pred-fn]
  (lentes/lens
   (fn [state] (filter pred-fn state))
   (fn [state update-fn] (map #(if (pred-fn %) (update-fn %) %) state))))

(comment
  (lentes/focus (filter-sequence neg?) [-1 0 1])
  (lentes/over (filter-sequence neg?) inc [-1 0 1])

  (lentes/focus (comp (spread-lens transform-on-read [inc identity dec]) (filter-sequence neg?)) 0))

(defn map-lens-over-sequence
  "A lens which, passed a sequence, applies the underlying lens to each entry, returning ."
  [underlying-lens]
  (lentes/lens
   (fn [sequence] (map #(lentes/focus underlying-lens %) sequence))
   (fn [sequence update-fn] (map #(lentes/over underlying-lens update-fn %) sequence))))

(comment
  (lentes/over (map-lens-over-sequence lentes/id) inc [1 2 3]))

(defn all-elements-lens
  "Applies an `underlying-lens` to all elements (generated by `elements-fn`) of the underlying state"
  ([underlying-lens] (all-elements-lens underlying-lens identity))
  ([underlying-lens elements-fn]
   (lentes/lens
    (fn [state] (map #(lentes/focus (underlying-lens %) state) (elements-fn state)))
    (fn [state update-fn]
      (reduce
       (fn [state elem] (lentes/over (underlying-lens elem) update-fn state))
       state
       (elements-fn state))))))

(comment
  ;; This is more complex than `map-lens-over-sequence` above, but it preserves the vector.
  (lentes/over (all-elements-lens lentes/nth #(map-indexed (fn [i _] i) %)) inc [1 2 3])
  ;; ... and also works on (for example) maps.
  (lentes/over (all-elements-lens lentes/key keys) inc {:x 1 :y 2}))

(defn validated-writes
  "Schema-on-write lens, which validates changes to the underlying state through a Malli schema, throwing on failure.
  
  Useful for derived atoms!"
  [schema]
  (let [explainer (m/explainer schema)
        error!    #(throw (ex-info "Value failed schema validation in cl/validated" {:schema      (m/form schema)
                                                                                     :value       %1
                                                                                     :explanation %2
                                                                                     :humanized   (me/humanize %2)}))]
    (lentes/lens
     identity
     (fn [state update-fn]
       (let [updated-value (update-fn state)]
         (when-let [explanation (explainer updated-value)]
           (error! state explanation))
         updated-value)))))
